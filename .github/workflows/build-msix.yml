name: Build MSIX

on:
  workflow_dispatch:
    inputs:
      msix_identity_name:
        description: "Optional MSIX Identity.Name (Package identity name), e.g. QoreDB.QoreDB"
        required: false
        default: ""

jobs:
  msix:
    runs-on: windows-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'pnpm'

      - name: Install frontend dependencies
        run: pnpm install

      - name: Build Tauri app (Windows)
        uses: tauri-apps/tauri-action@v0
        timeout-minutes: 30
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          args: --verbose

      - name: Build MSIX
        shell: pwsh
        env:
          MSIX_CERT_BASE64: ${{ secrets.MSIX_CERT_BASE64 }}
          MSIX_CERT_PASSWORD: ${{ secrets.MSIX_CERT_PASSWORD }}
          MSIX_PUBLISHER: ${{ secrets.MSIX_PUBLISHER }}
          MSIX_IDENTITY_NAME: ${{ github.event.inputs.msix_identity_name }}
        run: |
          $ErrorActionPreference = "Stop"

          $version = node -p "require('./package.json').version"
          $productName = node -p "require('./src-tauri/tauri.conf.json').productName"

          if (-not $productName) { $productName = "QoreDB" }

          $identifier = $env:MSIX_IDENTITY_NAME
          if ($identifier) { $identifier = $identifier.Trim() }
          if (-not $identifier) { $identifier = "QoreDB.QoreDB" }

          $semver = $version.Split('-')[0].Split('+')[0]
          $parts = $semver.Split('.')
          while ($parts.Length -lt 4) { $parts += "0" }
          $msixVersion = ($parts[0..3] -join '.')

          $exePath = "src-tauri/target/release/qoredb.exe"
          if (-not (Test-Path $exePath)) {
            $candidate = "src-tauri/target/release/$productName.exe"
            if (Test-Path $candidate) { $exePath = $candidate }
          }
          if (-not (Test-Path $exePath)) { throw "Executable not found at $exePath" }

          $staging = "src-tauri/target/release/bundle/msix-staging"
          $outDir = "src-tauri/target/release/bundle/msix"
          New-Item -ItemType Directory -Force -Path $staging | Out-Null
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          Copy-Item $exePath -Destination (Join-Path $staging "qoredb.exe") -Force

          $iconLarge = "src-tauri/icons/128x128.png"
          $iconSmall = "src-tauri/icons/32x32.png"
          if (-not (Test-Path $iconSmall)) { $iconSmall = $iconLarge }
          Copy-Item $iconLarge -Destination (Join-Path $staging "Square150x150Logo.png") -Force
          Copy-Item $iconSmall -Destination (Join-Path $staging "Square44x44Logo.png") -Force

          $publisher = $env:MSIX_PUBLISHER
          if ($publisher) { $publisher = $publisher.Trim() }
          if (-not $publisher) { $publisher = "CN=B4F140BE-726E-4427-93B8-EAF78B5D2E9E" }

          function ConvertTo-CrockfordBase32([byte[]]$bytes) {
            $alphabet = "0123456789abcdefghjkmnpqrstvwxyz"
            $bits = 0
            $value = 0
            $output = ""
            foreach ($b in $bytes) {
              $value = (($value -shl 8) -bor $b)
              $bits += 8
              while ($bits -ge 5) {
                $index = ($value -shr ($bits - 5)) -band 31
                $output += $alphabet[$index]
                $bits -= 5
              }
            }
            if ($bits -gt 0) {
              $index = ($value -shl (5 - $bits)) -band 31
              $output += $alphabet[$index]
            }
            return $output
          }

          function Get-PublisherId([string]$publisherName) {
            $normalized = $publisherName.Trim()
            $bytes = [System.Text.Encoding]::Unicode.GetBytes($normalized) # UTF-16LE
            $sha = [System.Security.Cryptography.SHA256]::Create()
            $hash = $sha.ComputeHash($bytes)
            $b32 = ConvertTo-CrockfordBase32 $hash
            return $b32.Substring(0, 13)
          }

          $publisherId = Get-PublisherId $publisher
          Write-Host "MSIX Computed PublisherId: $publisherId"
          Write-Host "MSIX Computed PackageFamilyName: ${identifier}_$publisherId"

          $manifestTemplate = Get-Content "scripts/msix/AppxManifest.xml" -Raw
          $manifest = $manifestTemplate `
            -replace "{{IDENTIFIER}}", $identifier `
            -replace "{{PUBLISHER}}", $publisher `
            -replace "{{VERSION}}", $msixVersion `
            -replace "{{DISPLAY_NAME}}", $productName `
            -replace "{{EXECUTABLE}}", "qoredb.exe" `
            -replace "{{APP_ID}}", "QoreDB"

          $manifestPath = Join-Path $staging "AppxManifest.xml"
          $manifest | Set-Content $manifestPath -Encoding utf8

          [xml]$manifestXml = Get-Content $manifestPath
          Write-Host "MSIX Manifest Identity.Name: $($manifestXml.Package.Identity.Name)"
          Write-Host "MSIX Manifest Identity.Publisher: $($manifestXml.Package.Identity.Publisher)"

          $makeappx = (Get-Command makeappx.exe -ErrorAction SilentlyContinue).Source
          if (-not $makeappx) {
            $makeappx = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe" `
              -ErrorAction SilentlyContinue | Sort-Object FullName -Descending | Select-Object -First 1 | ForEach-Object { $_.FullName }
          }
          if (-not $makeappx) { throw "makeappx.exe not found on runner" }

          $safeName = ($productName -replace '[^A-Za-z0-9._-]', '')
          if (-not $safeName) { $safeName = "QoreDB" }

          $msixFile = ("{0}_{1}_x64.msix" -f $safeName, $version)
          $msixPath = Join-Path $outDir $msixFile

          & $makeappx pack /d $staging /p $msixPath /o | Out-Null

          if ($env:MSIX_CERT_BASE64) {
            $pfxPath = Join-Path $env:RUNNER_TEMP "msixcert.pfx"
            [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:MSIX_CERT_BASE64))

            try {
              if ($env:MSIX_CERT_PASSWORD) {
                $pfxBytes = [IO.File]::ReadAllBytes($pfxPath)
                $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                  $pfxBytes,
                  $env:MSIX_CERT_PASSWORD,
                  [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::DefaultKeySet
                )
                if ($cert.Subject) { Write-Host "MSIX Signing cert subject: $($cert.Subject)" }
              }
            } catch {
              Write-Host "Could not read PFX subject: $($_.Exception.Message)"
            }

            $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue).Source
            if (-not $signtool) {
              $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" `
                -ErrorAction SilentlyContinue | Sort-Object FullName -Descending | Select-Object -First 1 | ForEach-Object { $_.FullName }
            }
            if (-not $signtool) { throw "signtool.exe not found on runner" }

            & $signtool sign /fd SHA256 /f $pfxPath /p $env:MSIX_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $msixPath | Out-Null
          } else {
            Write-Host "MSIX_CERT_BASE64 not set: skipping signing"
          }

          Write-Host "MSIX output: $msixPath"

      - name: Upload MSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: msix
          path: src-tauri/target/release/bundle/msix/*.msix
          if-no-files-found: error
