name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            target: 'aarch64-apple-darwin'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            target: 'x86_64-apple-darwin'
          - platform: 'ubuntu-22.04'
            args: ''
            target: ''
          - platform: 'windows-latest'
            args: ''
            target: ''

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'pnpm'

      - name: Install frontend dependencies
        run: pnpm install

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        timeout-minutes: 30
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'QoreDB ${{ github.ref_name }}'
          releaseBody: 'See the assets to download and install this version.'
          releaseDraft: true
          prerelease: false
          includeUpdaterJson: true
          args: ${{ matrix.args }} --verbose

      - name: Build MSIX (Windows only)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        env:
          MSIX_CERT_BASE64: ${{ secrets.MSIX_CERT_BASE64 }}
          MSIX_CERT_PASSWORD: ${{ secrets.MSIX_CERT_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          $version = node -p "require('./package.json').version"
          $productName = node -p "require('./src-tauri/tauri.conf.json').productName"
          $identifier = $env:MSIX_IDENTITY_NAME
          if ($identifier) { $identifier = $identifier.Trim() }

          if (-not $productName) { $productName = "QoreDB" }
          if (-not $identifier) { $identifier = "QoreDB.QoreDB" }

          $semver = $version.Split('-')[0].Split('+')[0]
          $parts = $semver.Split('.')
          while ($parts.Length -lt 4) { $parts += "0" }
          $msixVersion = ($parts[0..3] -join '.')

          $exePath = "src-tauri/target/release/qoredb.exe"
          if (-not (Test-Path $exePath)) {
            $candidate = "src-tauri/target/release/$productName.exe"
            if (Test-Path $candidate) {
              $exePath = $candidate
            }
          }
          if (-not (Test-Path $exePath)) {
            throw "Executable not found at $exePath"
          }

          $staging = "src-tauri/target/release/bundle/msix-staging"
          $outDir = "src-tauri/target/release/bundle/msix"
          New-Item -ItemType Directory -Force -Path $staging | Out-Null
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          Copy-Item $exePath -Destination (Join-Path $staging "qoredb.exe") -Force

          $iconLarge = "src-tauri/icons/128x128.png"
          $iconSmall = "src-tauri/icons/32x32.png"
          if (-not (Test-Path $iconSmall)) { $iconSmall = $iconLarge }
          Copy-Item $iconLarge -Destination (Join-Path $staging "Square150x150Logo.png") -Force
          Copy-Item $iconSmall -Destination (Join-Path $staging "Square44x44Logo.png") -Force

          $publisher = $env:MSIX_PUBLISHER
          if ($publisher) { $publisher = $publisher.Trim() }
          if (-not $publisher) { $publisher = "CN=B4F140BE-726E-4427-93B8-EAF78B5D2E9E" }

          function ConvertTo-CrockfordBase32([byte[]]$bytes) {
            $alphabet = "0123456789abcdefghjkmnpqrstvwxyz"
            $bits = 0
            $value = 0
            $output = ""
            foreach ($b in $bytes) {
              $value = (($value -shl 8) -bor $b)
              $bits += 8
              while ($bits -ge 5) {
                $index = ($value -shr ($bits - 5)) -band 31
                $output += $alphabet[$index]
                $bits -= 5
              }
            }
            if ($bits -gt 0) {
              $index = ($value -shl (5 - $bits)) -band 31
              $output += $alphabet[$index]
            }
            return $output
          }

          function Get-PublisherId([string]$publisherName) {
            # PFN uses UTF-16LE of the Publisher string (case-sensitive in practice).
            # Do not force lower/upper here; Partner Center expects a specific hash.
            $normalized = $publisherName.Trim()
            $bytes = [System.Text.Encoding]::Unicode.GetBytes($normalized) # UTF-16LE
            $sha = [System.Security.Cryptography.SHA256]::Create()
            $hash = $sha.ComputeHash($bytes)
            $b32 = ConvertTo-CrockfordBase32 $hash
            return $b32.Substring(0, 13)
          }

          $publisherId = Get-PublisherId $publisher
          Write-Host "MSIX Computed PublisherId: $publisherId"
          Write-Host "MSIX Computed PackageFamilyName: ${identifier}_$publisherId"
          $manifestTemplate = Get-Content "scripts/msix/AppxManifest.xml" -Raw
          $manifest = $manifestTemplate `
            -replace "{{IDENTIFIER}}", $identifier `
            -replace "{{PUBLISHER}}", $publisher `
            -replace "{{VERSION}}", $msixVersion `
            -replace "{{DISPLAY_NAME}}", $productName `
            -replace "{{EXECUTABLE}}", "qoredb.exe" `
            -replace "{{APP_ID}}", "QoreDB"

          $manifest | Set-Content (Join-Path $staging "AppxManifest.xml") -Encoding utf8

          # Diagnostics (safe): verify manifest identity matches Partner Center expectations
          $manifestPath = Join-Path $staging "AppxManifest.xml"
          [xml]$manifestXml = Get-Content $manifestPath
          Write-Host "MSIX Manifest Identity.Name: $($manifestXml.Package.Identity.Name)"
          Write-Host "MSIX Manifest Identity.Publisher: $($manifestXml.Package.Identity.Publisher)"

          $makeappx = (Get-Command makeappx.exe -ErrorAction SilentlyContinue).Source
          if (-not $makeappx) {
            $makeappx = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe" `
              -ErrorAction SilentlyContinue | Sort-Object FullName -Descending | Select-Object -First 1 | ForEach-Object { $_.FullName }
          }
          if (-not $makeappx) { throw "makeappx.exe not found on runner" }

          $safeName = ($productName -replace '[^A-Za-z0-9._-]', '')
          if (-not $safeName) { $safeName = "QoreDB" }
          $msixFile = ("{0}_{1}_x64.msix" -f $safeName, $version)
          $msixPath = Join-Path $outDir $msixFile

          & $makeappx pack /d $staging /p $msixPath /o | Out-Null

          if ($env:MSIX_CERT_BASE64) {
            $pfxPath = Join-Path $env:RUNNER_TEMP "msixcert.pfx"
            [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:MSIX_CERT_BASE64))

            # Diagnostics (safe): print the subject of the signing cert
            try {
              if ($env:MSIX_CERT_PASSWORD) {
                $pfxBytes = [IO.File]::ReadAllBytes($pfxPath)
                $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                  $pfxBytes,
                  $env:MSIX_CERT_PASSWORD,
                  [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::DefaultKeySet
                )
                if ($cert.Subject) {
                  Write-Host "MSIX Signing cert subject: $($cert.Subject)"
                }
              } else {
                Write-Host "MSIX Signing cert subject: (skipped, MSIX_CERT_PASSWORD not set)"
              }
            } catch {
              Write-Host "Could not read PFX subject: $($_.Exception.Message)"
            }

            $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue).Source
            if (-not $signtool) {
              $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" `
                -ErrorAction SilentlyContinue | Sort-Object FullName -Descending | Select-Object -First 1 | ForEach-Object { $_.FullName }
            }
            if (-not $signtool) { throw "signtool.exe not found on runner" }

            & $signtool sign /fd SHA256 /f $pfxPath /p $env:MSIX_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $msixPath | Out-Null
          }

          $repo = "${{ github.repository }}"
          $tag = "${{ github.ref_name }}"
          $appinstallerName = "$safeName.appinstaller"
          $appinstallerPath = Join-Path $outDir $appinstallerName
          $appinstallerUrl = "https://github.com/$repo/releases/download/$tag/$appinstallerName"
          $msixUrl = "https://github.com/$repo/releases/download/$tag/$msixFile"

          $appinstaller = @(
            '<?xml version="1.0" encoding="utf-8"?>',
            "<AppInstaller Uri=""$appinstallerUrl"" Version=""$msixVersion"" xmlns=""http://schemas.microsoft.com/appx/appinstaller/2018"">",
            "  <MainPackage Name=""$identifier"" Publisher=""$publisher"" Version=""$msixVersion"" ProcessorArchitecture=""x64"" Uri=""$msixUrl"" />",
            "  <UpdateSettings>",
            "    <OnLaunch HoursBetweenUpdateChecks=""6"" />",
            "  </UpdateSettings>",
            "</AppInstaller>"
          ) -join "`n"

          $appinstaller | Set-Content $appinstallerPath -Encoding utf8

      - name: Upload MSIX to release
        if: matrix.platform == 'windows-latest'
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: |
            src-tauri/target/release/bundle/msix/*.msix
            src-tauri/target/release/bundle/msix/*.appinstaller
